// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'json_hero_builder.dart';

// **************************************************************************
// Generator: JsonWidgetLibraryBuilder
// **************************************************************************

// ignore_for_file: avoid_init_to_null
// ignore_for_file: deprecated_member_use

// ignore_for_file: prefer_const_constructors
// ignore_for_file: prefer_const_constructors_in_immutables
// ignore_for_file: prefer_final_locals
// ignore_for_file: prefer_if_null_operators
// ignore_for_file: prefer_single_quotes
// ignore_for_file: unused_local_variable

class JsonHeroBuilder extends _JsonHeroBuilder {
  const JsonHeroBuilder({required super.args});

  static const kType = 'hero';

  /// Constant that can be referenced for the builder's type.
  @override
  String get type => kType;

  /// Static function that is capable of decoding the widget from a dynamic JSON
  /// or YAML set of values.
  static JsonHeroBuilder fromDynamic(
    dynamic map, {
    JsonWidgetRegistry? registry,
  }) => JsonHeroBuilder(args: map);

  @override
  JsonHeroBuilderModel createModel({
    ChildWidgetBuilder? childBuilder,
    required JsonWidgetData data,
  }) {
    final model = JsonHeroBuilderModel.fromDynamic(
      args,
      registry: data.jsonWidgetRegistry,
    );

    return model;
  }

  @override
  Hero buildCustom({
    ChildWidgetBuilder? childBuilder,
    required BuildContext context,
    required JsonWidgetData data,
    Key? key,
  }) {
    final model = createModel(childBuilder: childBuilder, data: data);

    return Hero(
      createRectTween: model.createRectTween,
      flightShuttleBuilder: model.flightShuttleBuilder,
      key: key,
      placeholderBuilder: model.placeholderBuilder,
      tag: model.tag,
      transitionOnUserGestures: model.transitionOnUserGestures,
      child: model.child.build(childBuilder: childBuilder, context: context),
    );
  }
}

class JsonHero extends JsonWidgetData {
  JsonHero({
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
    this.createRectTween,
    this.flightShuttleBuilder,
    this.placeholderBuilder,
    this.tag = '(default)',
    this.transitionOnUserGestures = false,
    required this.child,
  }) : super(
         jsonWidgetArgs: JsonHeroBuilderModel.fromDynamic(
           {
             'createRectTween': createRectTween,
             'flightShuttleBuilder': flightShuttleBuilder,
             'placeholderBuilder': placeholderBuilder,
             'tag': tag,
             'transitionOnUserGestures': transitionOnUserGestures,
             'child': child,

             ...args,
           },
           args: args,
           registry: registry,
         ),
         jsonWidgetBuilder:
             () => JsonHeroBuilder(
               args: JsonHeroBuilderModel.fromDynamic(
                 {
                   'createRectTween': createRectTween,
                   'flightShuttleBuilder': flightShuttleBuilder,
                   'placeholderBuilder': placeholderBuilder,
                   'tag': tag,
                   'transitionOnUserGestures': transitionOnUserGestures,
                   'child': child,

                   ...args,
                 },
                 args: args,
                 registry: registry,
               ),
             ),
         jsonWidgetType: JsonHeroBuilder.kType,
       );

  /* AUTOGENERATED FROM [Hero.createRectTween]*/
  /// Defines how the destination hero's bounds change as it flies from the starting
  /// route to the destination route.
  ///
  /// A hero flight begins with the destination hero's [child] aligned with the
  /// starting hero's child. The [Tween<Rect>] returned by this callback is used
  /// to compute the hero's bounds as the flight animation's value goes from 0.0
  /// to 1.0.
  ///
  /// If this property is null, the default, then the value of
  /// [HeroController.createRectTween] is used. The [HeroController] created by
  /// [MaterialApp] creates a [MaterialRectArcTween].
  final Tween<Rect?> Function(Rect?, Rect?)? createRectTween;

  /* AUTOGENERATED FROM [Hero.flightShuttleBuilder]*/
  /// Optional override to supply a widget that's shown during the hero's flight.
  ///
  /// This in-flight widget can depend on the route transition's animation as
  /// well as the incoming and outgoing routes' [Hero] descendants' widgets and
  /// layout.
  ///
  /// When both the source and destination [Hero]es provide a [flightShuttleBuilder],
  /// the destination's [flightShuttleBuilder] takes precedence.
  ///
  /// If none is provided, the destination route's Hero child is shown in-flight
  /// by default.
  ///
  /// ## Limitations
  ///
  /// If a widget built by [flightShuttleBuilder] takes part in a [Navigator]
  /// push transition, that widget or its descendants must not have any
  /// [GlobalKey] that is used in the source Hero's descendant widgets. That is
  /// because both subtrees will be included in the widget tree during the Hero
  /// flight animation, and [GlobalKey]s must be unique across the entire widget
  /// tree.
  ///
  /// If the said [GlobalKey] is essential to your application, consider providing
  /// a custom [placeholderBuilder] for the source Hero, to avoid the [GlobalKey]
  /// collision, such as a builder that builds an empty [SizedBox], keeping the
  /// Hero [child]'s original size.
  final Widget Function(
    BuildContext,
    Animation<double>,
    HeroFlightDirection,
    BuildContext,
    BuildContext,
  )?
  flightShuttleBuilder;

  /* AUTOGENERATED FROM [Hero.placeholderBuilder]*/
  /// Placeholder widget left in place as the Hero's [child] once the flight takes
  /// off.
  ///
  /// By default the placeholder widget is an empty [SizedBox] keeping the Hero
  /// child's original size, unless this Hero is a source Hero of a [Navigator]
  /// push transition, in which case [child] will be a descendant of the placeholder
  /// and will be kept [Offstage] during the Hero's flight.
  final Widget Function(BuildContext, Size, Widget)? placeholderBuilder;

  /* AUTOGENERATED FROM [Hero.tag]*/
  /// The identifier for this particular hero. If the tag of this hero matches
  /// the tag of a hero on a [PageRoute] that we're navigating to or from, then
  /// a hero animation will be triggered.
  final Object tag;

  /* AUTOGENERATED FROM [Hero.transitionOnUserGestures]*/
  /// Whether to perform the hero transition if the [PageRoute] transition was
  /// triggered by a user gesture, such as a back swipe on iOS.
  ///
  /// If [Hero]es with the same [tag] on both the from and the to routes have
  /// [transitionOnUserGestures] set to true, a back swipe gesture will
  /// trigger the same hero animation as a programmatically triggered push or
  /// pop.
  ///
  /// The route being popped to or the bottom route must also have
  /// [PageRoute.maintainState] set to true for a gesture triggered hero
  /// transition to work.
  ///
  /// Defaults to false.
  final bool transitionOnUserGestures;

  /* AUTOGENERATED FROM [Hero.child]*/
  /// The widget subtree that will "fly" from one route to another during a
  /// [Navigator] push or pop transition.
  ///
  /// The appearance of this subtree should be similar to the appearance of
  /// the subtrees of any other heroes in the application with the same [tag].
  /// Changes in scale and aspect ratio work well in hero animations, changes
  /// in layout or composition do not.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final JsonWidgetData child;
}

/* AUTOGENERATED FROM [Hero]*/
/// Create a hero.
///
/// The [child] parameter and all of the its descendants must not be [Hero]es.
class JsonHeroBuilderModel extends JsonWidgetBuilderModel {
  const JsonHeroBuilderModel(
    super.args, {
    this.createRectTween,
    this.flightShuttleBuilder,
    this.placeholderBuilder,
    this.tag = '(default)',
    this.transitionOnUserGestures = false,
    required this.child,
  });

  /* AUTOGENERATED FROM [Hero.createRectTween]*/
  /// Defines how the destination hero's bounds change as it flies from the starting
  /// route to the destination route.
  ///
  /// A hero flight begins with the destination hero's [child] aligned with the
  /// starting hero's child. The [Tween<Rect>] returned by this callback is used
  /// to compute the hero's bounds as the flight animation's value goes from 0.0
  /// to 1.0.
  ///
  /// If this property is null, the default, then the value of
  /// [HeroController.createRectTween] is used. The [HeroController] created by
  /// [MaterialApp] creates a [MaterialRectArcTween].
  final Tween<Rect?> Function(Rect?, Rect?)? createRectTween;

  /* AUTOGENERATED FROM [Hero.flightShuttleBuilder]*/
  /// Optional override to supply a widget that's shown during the hero's flight.
  ///
  /// This in-flight widget can depend on the route transition's animation as
  /// well as the incoming and outgoing routes' [Hero] descendants' widgets and
  /// layout.
  ///
  /// When both the source and destination [Hero]es provide a [flightShuttleBuilder],
  /// the destination's [flightShuttleBuilder] takes precedence.
  ///
  /// If none is provided, the destination route's Hero child is shown in-flight
  /// by default.
  ///
  /// ## Limitations
  ///
  /// If a widget built by [flightShuttleBuilder] takes part in a [Navigator]
  /// push transition, that widget or its descendants must not have any
  /// [GlobalKey] that is used in the source Hero's descendant widgets. That is
  /// because both subtrees will be included in the widget tree during the Hero
  /// flight animation, and [GlobalKey]s must be unique across the entire widget
  /// tree.
  ///
  /// If the said [GlobalKey] is essential to your application, consider providing
  /// a custom [placeholderBuilder] for the source Hero, to avoid the [GlobalKey]
  /// collision, such as a builder that builds an empty [SizedBox], keeping the
  /// Hero [child]'s original size.
  final Widget Function(
    BuildContext,
    Animation<double>,
    HeroFlightDirection,
    BuildContext,
    BuildContext,
  )?
  flightShuttleBuilder;

  /* AUTOGENERATED FROM [Hero.placeholderBuilder]*/
  /// Placeholder widget left in place as the Hero's [child] once the flight takes
  /// off.
  ///
  /// By default the placeholder widget is an empty [SizedBox] keeping the Hero
  /// child's original size, unless this Hero is a source Hero of a [Navigator]
  /// push transition, in which case [child] will be a descendant of the placeholder
  /// and will be kept [Offstage] during the Hero's flight.
  final Widget Function(BuildContext, Size, Widget)? placeholderBuilder;

  /* AUTOGENERATED FROM [Hero.tag]*/
  /// The identifier for this particular hero. If the tag of this hero matches
  /// the tag of a hero on a [PageRoute] that we're navigating to or from, then
  /// a hero animation will be triggered.
  final Object tag;

  /* AUTOGENERATED FROM [Hero.transitionOnUserGestures]*/
  /// Whether to perform the hero transition if the [PageRoute] transition was
  /// triggered by a user gesture, such as a back swipe on iOS.
  ///
  /// If [Hero]es with the same [tag] on both the from and the to routes have
  /// [transitionOnUserGestures] set to true, a back swipe gesture will
  /// trigger the same hero animation as a programmatically triggered push or
  /// pop.
  ///
  /// The route being popped to or the bottom route must also have
  /// [PageRoute.maintainState] set to true for a gesture triggered hero
  /// transition to work.
  ///
  /// Defaults to false.
  final bool transitionOnUserGestures;

  /* AUTOGENERATED FROM [Hero.child]*/
  /// The widget subtree that will "fly" from one route to another during a
  /// [Navigator] push or pop transition.
  ///
  /// The appearance of this subtree should be similar to the appearance of
  /// the subtrees of any other heroes in the application with the same [tag].
  /// Changes in scale and aspect ratio work well in hero animations, changes
  /// in layout or composition do not.
  ///
  /// {@macro flutter.widgets.ProxyWidget.child}
  final JsonWidgetData child;

  static JsonHeroBuilderModel fromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    final result = maybeFromDynamic(map, args: args, registry: registry);

    if (result == null) {
      throw Exception(
        '[JsonHeroBuilder]: requested to parse from dynamic, but the input is null.',
      );
    }

    return result;
  }

  static JsonHeroBuilderModel? maybeFromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    JsonHeroBuilderModel? result;

    if (map != null) {
      if (map is String) {
        map = yaon.parse(map, normalize: true);
      }

      if (map is JsonHeroBuilderModel) {
        result = map;
      } else {
        registry ??= JsonWidgetRegistry.instance;
        map = registry.processArgs(map, <String>{}).value;
        result = JsonHeroBuilderModel(
          args,
          createRectTween: map['createRectTween'],
          flightShuttleBuilder: map['flightShuttleBuilder'],
          placeholderBuilder: map['placeholderBuilder'],
          tag: map['tag'] ?? '(default)',
          transitionOnUserGestures: JsonClass.parseBool(
            map['transitionOnUserGestures'],
            whenNull: false,
          ),
          child: () {
            dynamic parsed = JsonWidgetData.fromDynamic(
              map['child'],
              registry: registry,
            );

            if (parsed == null) {
              throw Exception(
                'Null value encountered for required parameter: [child].',
              );
            }
            return parsed;
          }(),
        );
      }
    }

    return result;
  }

  @override
  Map<String, dynamic> toJson() {
    return JsonClass.removeNull({
      'createRectTween': createRectTween,
      'flightShuttleBuilder': flightShuttleBuilder,
      'placeholderBuilder': placeholderBuilder,
      'tag': '(default)' == tag ? null : tag,
      'transitionOnUserGestures':
          false == transitionOnUserGestures ? null : transitionOnUserGestures,
      'child': child.toJson(),

      ...args,
    });
  }
}

class HeroSchema {
  static const id =
      'https://peiffer-innovations.github.io/flutter_json_schemas/schemas/json_dynamic_widget/hero.json';

  static final schema = <String, Object>{
    r'$schema': 'http://json-schema.org/draft-07/schema#',
    r'$id': id,
    'title': 'Hero',
    'type': 'object',
    'additionalProperties': false,
    'properties': {
      'createRectTween': SchemaHelper.anySchema,
      'flightShuttleBuilder': SchemaHelper.anySchema,
      'placeholderBuilder': SchemaHelper.anySchema,
      'tag': SchemaHelper.anySchema,
      'transitionOnUserGestures': SchemaHelper.boolSchema,
      'child': SchemaHelper.objectSchema(JsonWidgetDataSchema.id),
    },
    'required': ['tag', 'child'],
  };
}
