// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'json_tween_animation_builder_builder.dart';

// **************************************************************************
// Generator: JsonWidgetLibraryBuilder
// **************************************************************************

// ignore_for_file: avoid_init_to_null
// ignore_for_file: deprecated_member_use

// ignore_for_file: prefer_const_constructors
// ignore_for_file: prefer_const_constructors_in_immutables
// ignore_for_file: prefer_final_locals
// ignore_for_file: prefer_if_null_operators
// ignore_for_file: prefer_single_quotes
// ignore_for_file: unused_local_variable

class JsonTweenAnimationBuilderBuilder
    extends _JsonTweenAnimationBuilderBuilder {
  const JsonTweenAnimationBuilderBuilder({required super.args});

  static const kType = 'tween_animation_builder';

  /// Constant that can be referenced for the builder's type.
  @override
  String get type => kType;

  /// Static function that is capable of decoding the widget from a dynamic JSON
  /// or YAML set of values.
  static JsonTweenAnimationBuilderBuilder fromDynamic(
    dynamic map, {
    JsonWidgetRegistry? registry,
  }) => JsonTweenAnimationBuilderBuilder(args: map);

  @override
  JsonTweenAnimationBuilderBuilderModel createModel({
    ChildWidgetBuilder? childBuilder,
    required JsonWidgetData data,
  }) {
    final model = JsonTweenAnimationBuilderBuilderModel.fromDynamic(
      args,
      registry: data.jsonWidgetRegistry,
    );

    return model;
  }

  @override
  TweenAnimationBuilder<Object?> buildCustom({
    ChildWidgetBuilder? childBuilder,
    required BuildContext context,
    required JsonWidgetData data,
    Key? key,
  }) {
    final model = createModel(childBuilder: childBuilder, data: data);

    final tweenDecoded = _decodeTween(value: model.tween);

    return TweenAnimationBuilder<Object?>(
      builder: model.builder,
      curve: model.curve,
      duration: model.duration,
      key: key,
      onEnd: model.onEnd,
      tween: tweenDecoded,
      child: model.child?.build(childBuilder: childBuilder, context: context),
    );
  }
}

class JsonTweenAnimationBuilder extends JsonWidgetData {
  JsonTweenAnimationBuilder({
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
    required this.builder,
    this.curve = Curves.linear,
    required this.duration,
    this.onEnd,
    required this.tween,
    this.child,
  }) : super(
         jsonWidgetArgs: JsonTweenAnimationBuilderBuilderModel.fromDynamic(
           {
             'builder': builder,
             'curve': curve,
             'duration': duration,
             'onEnd': onEnd,
             'tween': tween,
             'child': child,

             ...args,
           },
           args: args,
           registry: registry,
         ),
         jsonWidgetBuilder:
             () => JsonTweenAnimationBuilderBuilder(
               args: JsonTweenAnimationBuilderBuilderModel.fromDynamic(
                 {
                   'builder': builder,
                   'curve': curve,
                   'duration': duration,
                   'onEnd': onEnd,
                   'tween': tween,
                   'child': child,

                   ...args,
                 },
                 args: args,
                 registry: registry,
               ),
             ),
         jsonWidgetType: JsonTweenAnimationBuilderBuilder.kType,
       );

  /* AUTOGENERATED FROM [TweenAnimationBuilder<Object?>.builder]*/
  /// Called every time the animation value changes.
  ///
  /// The current animation value is passed to the builder along with the
  /// [child]. The builder should build a [Widget] based on the current
  /// animation value and incorporate the [child] into it, if it is non-null.
  final Widget Function(BuildContext, Object?, Widget?) builder;

  final Curve curve;

  final Duration duration;

  final void Function()? onEnd;

  /* AUTOGENERATED FROM [TweenAnimationBuilder<Object?>.tween]*/
  /// Defines the target value for the animation.
  ///
  /// When the widget first builds, the animation runs from [Tween.begin] to
  /// [Tween.end], if [Tween.begin] is non-null. A new animation can be
  /// triggered at anytime by providing a new [Tween] with a new [Tween.end]
  /// value. The new animation runs from the current animation value (which may
  /// be [Tween.end] of the old [tween], if that animation completed) to
  /// [Tween.end] of the new [tween]. The [Tween.begin] value is ignored except
  /// for the initial animation that is triggered when the widget builds for the
  /// first time.
  ///
  /// Any (subclass of) [Tween] is accepted as an argument. For example, to
  /// animate the height or width of a [Widget], use a [Tween<double>], or
  /// check out the [ColorTween] to animate the color property of a [Widget].
  ///
  /// Any [Tween] provided must have a non-null [Tween.end] value.
  ///
  /// ## Ownership
  ///
  /// The [TweenAnimationBuilder] takes full ownership of the provided [Tween]
  /// and it will mutate the [Tween]. Once a [Tween] instance has been passed
  /// to [TweenAnimationBuilder] its properties should not be accessed or
  /// changed anymore to avoid any interference with the
  /// [TweenAnimationBuilder]. If you need to change the [Tween], create a
  /// **new instance** with the new values.
  ///
  /// It is good practice to never store a [Tween] provided to a
  /// [TweenAnimationBuilder] in an instance variable to avoid accidental
  /// modifications of the [Tween].
  final dynamic tween;

  /* AUTOGENERATED FROM [TweenAnimationBuilder<Object?>.child]*/
  /// The child widget to pass to the builder.
  ///
  /// If a builder callback's return value contains a subtree that does not
  /// depend on the animation, it's more efficient to build that subtree once
  /// instead of rebuilding it on every animation tick.
  ///
  /// If the pre-built subtree is passed as the child parameter, the
  /// [TweenAnimationBuilder] will pass it back to the [builder] function so
  /// that it can be incorporated into the build.
  ///
  /// Using this pre-built child is entirely optional, but can improve
  /// performance significantly in some cases and is therefore a good practice.
  final JsonWidgetData? child;
}

/* AUTOGENERATED FROM [TweenAnimationBuilder<Object?>]*/
/// Creates a [TweenAnimationBuilder].
///
/// The [TweenAnimationBuilder] takes full ownership of the provided [tween]
/// instance and mutates it. Once a [Tween] has been passed to a
/// [TweenAnimationBuilder], its properties should not be accessed or changed
/// anymore to avoid interference with the [TweenAnimationBuilder].
class JsonTweenAnimationBuilderBuilderModel extends JsonWidgetBuilderModel {
  const JsonTweenAnimationBuilderBuilderModel(
    super.args, {
    required this.builder,
    this.curve = Curves.linear,
    required this.duration,
    this.onEnd,
    required this.tween,
    this.child,
  });

  /* AUTOGENERATED FROM [TweenAnimationBuilder<Object?>.builder]*/
  /// Called every time the animation value changes.
  ///
  /// The current animation value is passed to the builder along with the
  /// [child]. The builder should build a [Widget] based on the current
  /// animation value and incorporate the [child] into it, if it is non-null.
  final Widget Function(BuildContext, Object?, Widget?) builder;

  final Curve curve;

  final Duration duration;

  final void Function()? onEnd;

  /* AUTOGENERATED FROM [TweenAnimationBuilder<Object?>.tween]*/
  /// Defines the target value for the animation.
  ///
  /// When the widget first builds, the animation runs from [Tween.begin] to
  /// [Tween.end], if [Tween.begin] is non-null. A new animation can be
  /// triggered at anytime by providing a new [Tween] with a new [Tween.end]
  /// value. The new animation runs from the current animation value (which may
  /// be [Tween.end] of the old [tween], if that animation completed) to
  /// [Tween.end] of the new [tween]. The [Tween.begin] value is ignored except
  /// for the initial animation that is triggered when the widget builds for the
  /// first time.
  ///
  /// Any (subclass of) [Tween] is accepted as an argument. For example, to
  /// animate the height or width of a [Widget], use a [Tween<double>], or
  /// check out the [ColorTween] to animate the color property of a [Widget].
  ///
  /// Any [Tween] provided must have a non-null [Tween.end] value.
  ///
  /// ## Ownership
  ///
  /// The [TweenAnimationBuilder] takes full ownership of the provided [Tween]
  /// and it will mutate the [Tween]. Once a [Tween] instance has been passed
  /// to [TweenAnimationBuilder] its properties should not be accessed or
  /// changed anymore to avoid any interference with the
  /// [TweenAnimationBuilder]. If you need to change the [Tween], create a
  /// **new instance** with the new values.
  ///
  /// It is good practice to never store a [Tween] provided to a
  /// [TweenAnimationBuilder] in an instance variable to avoid accidental
  /// modifications of the [Tween].
  final dynamic tween;

  /* AUTOGENERATED FROM [TweenAnimationBuilder<Object?>.child]*/
  /// The child widget to pass to the builder.
  ///
  /// If a builder callback's return value contains a subtree that does not
  /// depend on the animation, it's more efficient to build that subtree once
  /// instead of rebuilding it on every animation tick.
  ///
  /// If the pre-built subtree is passed as the child parameter, the
  /// [TweenAnimationBuilder] will pass it back to the [builder] function so
  /// that it can be incorporated into the build.
  ///
  /// Using this pre-built child is entirely optional, but can improve
  /// performance significantly in some cases and is therefore a good practice.
  final JsonWidgetData? child;

  static JsonTweenAnimationBuilderBuilderModel fromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    final result = maybeFromDynamic(map, args: args, registry: registry);

    if (result == null) {
      throw Exception(
        '[JsonTweenAnimationBuilderBuilder]: requested to parse from dynamic, but the input is null.',
      );
    }

    return result;
  }

  static JsonTweenAnimationBuilderBuilderModel? maybeFromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    JsonTweenAnimationBuilderBuilderModel? result;

    if (map != null) {
      if (map is String) {
        map = yaon.parse(map, normalize: true);
      }

      if (map is JsonTweenAnimationBuilderBuilderModel) {
        result = map;
      } else {
        registry ??= JsonWidgetRegistry.instance;
        map = registry.processArgs(map, <String>{}).value;
        result = JsonTweenAnimationBuilderBuilderModel(
          args,
          builder: map['builder'],
          curve: () {
            dynamic parsed = CurvesValues.lookup(map['curve']);

            parsed ??= Curves.linear;

            return parsed;
          }(),
          duration: () {
            dynamic parsed = JsonClass.parseDurationFromMillis(map['duration']);

            if (parsed == null) {
              throw Exception(
                'Null value encountered for required parameter: [duration].',
              );
            }
            return parsed;
          }(),
          onEnd: map['onEnd'],
          tween: map['tween'],
          child: () {
            dynamic parsed = JsonWidgetData.maybeFromDynamic(
              map['child'],
              registry: registry,
            );

            return parsed;
          }(),
        );
      }
    }

    return result;
  }

  @override
  Map<String, dynamic> toJson() {
    return JsonClass.removeNull({
      'builder': builder,
      'curve': Curves.linear == curve ? null : CurvesValues.encode(curve),
      'duration': duration.inMilliseconds,
      'onEnd': onEnd,
      'tween': tween,
      'child': child?.toJson(),

      ...args,
    });
  }
}

class TweenAnimationBuilderSchema {
  static const id =
      'https://peiffer-innovations.github.io/flutter_json_schemas/schemas/json_dynamic_widget/tween_animation_builder.json';

  static final schema = <String, Object>{
    r'$schema': 'http://json-schema.org/draft-07/schema#',
    r'$id': id,
    'title': 'TweenAnimationBuilder',
    'type': 'object',
    'additionalProperties': false,
    'properties': {
      'builder': SchemaHelper.anySchema,
      'curve': SchemaHelper.anySchema,
      'duration': SchemaHelper.anySchema,
      'onEnd': SchemaHelper.anySchema,
      'tween': SchemaHelper.anySchema,
      'child': SchemaHelper.objectSchema(JsonWidgetDataSchema.id),
    },
    'required': ['builder', 'duration', 'tween'],
  };
}
