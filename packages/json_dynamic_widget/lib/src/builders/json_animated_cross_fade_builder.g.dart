// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'json_animated_cross_fade_builder.dart';

// **************************************************************************
// Generator: JsonWidgetLibraryBuilder
// **************************************************************************

// ignore_for_file: avoid_init_to_null
// ignore_for_file: deprecated_member_use

// ignore_for_file: prefer_const_constructors
// ignore_for_file: prefer_const_constructors_in_immutables
// ignore_for_file: prefer_final_locals
// ignore_for_file: prefer_if_null_operators
// ignore_for_file: prefer_single_quotes
// ignore_for_file: unused_local_variable

class JsonAnimatedCrossFadeBuilder extends _JsonAnimatedCrossFadeBuilder {
  const JsonAnimatedCrossFadeBuilder({required super.args});

  static const kType = 'animated_cross_fade';

  /// Constant that can be referenced for the builder's type.
  @override
  String get type => kType;

  /// Static function that is capable of decoding the widget from a dynamic JSON
  /// or YAML set of values.
  static JsonAnimatedCrossFadeBuilder fromDynamic(
    dynamic map, {
    JsonWidgetRegistry? registry,
  }) => JsonAnimatedCrossFadeBuilder(args: map);

  @override
  JsonAnimatedCrossFadeBuilderModel createModel({
    ChildWidgetBuilder? childBuilder,
    required JsonWidgetData data,
  }) {
    final model = JsonAnimatedCrossFadeBuilderModel.fromDynamic(
      args,
      registry: data.jsonWidgetRegistry,
    );

    return model;
  }

  @override
  AnimatedCrossFade buildCustom({
    ChildWidgetBuilder? childBuilder,
    required BuildContext context,
    required JsonWidgetData data,
    Key? key,
  }) {
    final model = createModel(childBuilder: childBuilder, data: data);

    final layoutBuilderDecoded = _decodeLayoutBuilder(
      value: model.layoutBuilder,
    );

    return AnimatedCrossFade(
      alignment: model.alignment,
      crossFadeState: model.crossFadeState,
      duration: model.duration,
      excludeBottomFocus: model.excludeBottomFocus,
      firstChild: model.firstChild.build(
        childBuilder: childBuilder,
        context: context,
      ),
      firstCurve: model.firstCurve,
      key: key,
      layoutBuilder: layoutBuilderDecoded,
      reverseDuration: model.reverseDuration,
      secondChild: model.secondChild.build(
        childBuilder: childBuilder,
        context: context,
      ),
      secondCurve: model.secondCurve,
      sizeCurve: model.sizeCurve,
    );
  }
}

class JsonAnimatedCrossFade extends JsonWidgetData {
  JsonAnimatedCrossFade({
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
    this.alignment = Alignment.topCenter,
    required this.crossFadeState,
    required this.duration,
    this.excludeBottomFocus = true,
    required this.firstChild,
    this.firstCurve = Curves.linear,
    this.layoutBuilder = AnimatedCrossFade.defaultLayoutBuilder,
    this.reverseDuration,
    required this.secondChild,
    this.secondCurve = Curves.linear,
    this.sizeCurve = Curves.linear,
  }) : super(
         jsonWidgetArgs: JsonAnimatedCrossFadeBuilderModel.fromDynamic(
           {
             'alignment': alignment,
             'crossFadeState': crossFadeState,
             'duration': duration,
             'excludeBottomFocus': excludeBottomFocus,
             'firstChild': firstChild,
             'firstCurve': firstCurve,
             'layoutBuilder': layoutBuilder,
             'reverseDuration': reverseDuration,
             'secondChild': secondChild,
             'secondCurve': secondCurve,
             'sizeCurve': sizeCurve,

             ...args,
           },
           args: args,
           registry: registry,
         ),
         jsonWidgetBuilder:
             () => JsonAnimatedCrossFadeBuilder(
               args: JsonAnimatedCrossFadeBuilderModel.fromDynamic(
                 {
                   'alignment': alignment,
                   'crossFadeState': crossFadeState,
                   'duration': duration,
                   'excludeBottomFocus': excludeBottomFocus,
                   'firstChild': firstChild,
                   'firstCurve': firstCurve,
                   'layoutBuilder': layoutBuilder,
                   'reverseDuration': reverseDuration,
                   'secondChild': secondChild,
                   'secondCurve': secondCurve,
                   'sizeCurve': sizeCurve,

                   ...args,
                 },
                 args: args,
                 registry: registry,
               ),
             ),
         jsonWidgetType: JsonAnimatedCrossFadeBuilder.kType,
       );

  /* AUTOGENERATED FROM [AnimatedCrossFade.alignment]*/
  /// How the children should be aligned while the size is animating.
  ///
  /// Defaults to [Alignment.topCenter].
  ///
  /// See also:
  ///
  ///  * [Alignment], a class with convenient constants typically used to
  ///    specify an [AlignmentGeometry].
  ///  * [AlignmentDirectional], like [Alignment] for specifying alignments
  ///    relative to text direction.
  final AlignmentGeometry alignment;

  /* AUTOGENERATED FROM [AnimatedCrossFade.crossFadeState]*/
  /// The child that will be shown when the animation has completed.
  final CrossFadeState crossFadeState;

  /* AUTOGENERATED FROM [AnimatedCrossFade.duration]*/
  /// The duration of the whole orchestrated animation.
  final Duration duration;

  /* AUTOGENERATED FROM [AnimatedCrossFade.excludeBottomFocus]*/
  /// When true, this is equivalent to wrapping the bottom widget with an [ExcludeFocus]
  /// widget while it is at the bottom of the cross-fade stack.
  ///
  /// Defaults to true. When it is false, the bottom widget in the cross-fade stack
  /// can remain in focus until the top widget requests focus. This is useful for
  /// animating between different [TextField]s so the keyboard remains open during the
  /// cross-fade animation.
  final bool excludeBottomFocus;

  /* AUTOGENERATED FROM [AnimatedCrossFade.firstChild]*/
  /// The child that is visible when [crossFadeState] is
  /// [CrossFadeState.showFirst]. It fades out when transitioning
  /// [crossFadeState] from [CrossFadeState.showFirst] to
  /// [CrossFadeState.showSecond] and vice versa.
  final JsonWidgetData firstChild;

  /* AUTOGENERATED FROM [AnimatedCrossFade.firstCurve]*/
  /// The fade curve of the first child.
  ///
  /// Defaults to [Curves.linear].
  final Curve firstCurve;

  /* AUTOGENERATED FROM [AnimatedCrossFade.layoutBuilder]*/
  /// A builder that positions the [firstChild] and [secondChild] widgets.
  ///
  /// The widget returned by this method is wrapped in an [AnimatedSize].
  ///
  /// By default, this uses [AnimatedCrossFade.defaultLayoutBuilder], which uses
  /// a [Stack] and aligns the `bottomChild` to the top of the stack while
  /// providing the `topChild` as the non-positioned child to fill the provided
  /// constraints. This works well when the [AnimatedCrossFade] is in a position
  /// to change size and when the children are not flexible. However, if the
  /// children are less fussy about their sizes (for example a
  /// [CircularProgressIndicator] inside a [Center]), or if the
  /// [AnimatedCrossFade] is being forced to a particular size, then it can
  /// result in the widgets jumping about when the cross-fade state is changed.
  final dynamic layoutBuilder;

  /* AUTOGENERATED FROM [AnimatedCrossFade.reverseDuration]*/
  /// The duration of the whole orchestrated animation when running in reverse.
  ///
  /// If not supplied, this defaults to [duration].
  final Duration? reverseDuration;

  /* AUTOGENERATED FROM [AnimatedCrossFade.secondChild]*/
  /// The child that is visible when [crossFadeState] is
  /// [CrossFadeState.showSecond]. It fades in when transitioning
  /// [crossFadeState] from [CrossFadeState.showFirst] to
  /// [CrossFadeState.showSecond] and vice versa.
  final JsonWidgetData secondChild;

  /* AUTOGENERATED FROM [AnimatedCrossFade.secondCurve]*/
  /// The fade curve of the second child.
  ///
  /// Defaults to [Curves.linear].
  final Curve secondCurve;

  /* AUTOGENERATED FROM [AnimatedCrossFade.sizeCurve]*/
  /// The curve of the animation between the two children's sizes.
  ///
  /// Defaults to [Curves.linear].
  final Curve sizeCurve;
}

/* AUTOGENERATED FROM [AnimatedCrossFade]*/
/// Creates a cross-fade animation widget.
///
/// The [duration] of the animation is the same for all components (fade in,
/// fade out, and size), and you can pass [Interval]s instead of [Curve]s in
/// order to have finer control, e.g., creating an overlap between the fades.
class JsonAnimatedCrossFadeBuilderModel extends JsonWidgetBuilderModel {
  const JsonAnimatedCrossFadeBuilderModel(
    super.args, {
    this.alignment = Alignment.topCenter,
    required this.crossFadeState,
    required this.duration,
    this.excludeBottomFocus = true,
    required this.firstChild,
    this.firstCurve = Curves.linear,
    this.layoutBuilder = AnimatedCrossFade.defaultLayoutBuilder,
    this.reverseDuration,
    required this.secondChild,
    this.secondCurve = Curves.linear,
    this.sizeCurve = Curves.linear,
  });

  /* AUTOGENERATED FROM [AnimatedCrossFade.alignment]*/
  /// How the children should be aligned while the size is animating.
  ///
  /// Defaults to [Alignment.topCenter].
  ///
  /// See also:
  ///
  ///  * [Alignment], a class with convenient constants typically used to
  ///    specify an [AlignmentGeometry].
  ///  * [AlignmentDirectional], like [Alignment] for specifying alignments
  ///    relative to text direction.
  final AlignmentGeometry alignment;

  /* AUTOGENERATED FROM [AnimatedCrossFade.crossFadeState]*/
  /// The child that will be shown when the animation has completed.
  final CrossFadeState crossFadeState;

  /* AUTOGENERATED FROM [AnimatedCrossFade.duration]*/
  /// The duration of the whole orchestrated animation.
  final Duration duration;

  /* AUTOGENERATED FROM [AnimatedCrossFade.excludeBottomFocus]*/
  /// When true, this is equivalent to wrapping the bottom widget with an [ExcludeFocus]
  /// widget while it is at the bottom of the cross-fade stack.
  ///
  /// Defaults to true. When it is false, the bottom widget in the cross-fade stack
  /// can remain in focus until the top widget requests focus. This is useful for
  /// animating between different [TextField]s so the keyboard remains open during the
  /// cross-fade animation.
  final bool excludeBottomFocus;

  /* AUTOGENERATED FROM [AnimatedCrossFade.firstChild]*/
  /// The child that is visible when [crossFadeState] is
  /// [CrossFadeState.showFirst]. It fades out when transitioning
  /// [crossFadeState] from [CrossFadeState.showFirst] to
  /// [CrossFadeState.showSecond] and vice versa.
  final JsonWidgetData firstChild;

  /* AUTOGENERATED FROM [AnimatedCrossFade.firstCurve]*/
  /// The fade curve of the first child.
  ///
  /// Defaults to [Curves.linear].
  final Curve firstCurve;

  /* AUTOGENERATED FROM [AnimatedCrossFade.layoutBuilder]*/
  /// A builder that positions the [firstChild] and [secondChild] widgets.
  ///
  /// The widget returned by this method is wrapped in an [AnimatedSize].
  ///
  /// By default, this uses [AnimatedCrossFade.defaultLayoutBuilder], which uses
  /// a [Stack] and aligns the `bottomChild` to the top of the stack while
  /// providing the `topChild` as the non-positioned child to fill the provided
  /// constraints. This works well when the [AnimatedCrossFade] is in a position
  /// to change size and when the children are not flexible. However, if the
  /// children are less fussy about their sizes (for example a
  /// [CircularProgressIndicator] inside a [Center]), or if the
  /// [AnimatedCrossFade] is being forced to a particular size, then it can
  /// result in the widgets jumping about when the cross-fade state is changed.
  final dynamic layoutBuilder;

  /* AUTOGENERATED FROM [AnimatedCrossFade.reverseDuration]*/
  /// The duration of the whole orchestrated animation when running in reverse.
  ///
  /// If not supplied, this defaults to [duration].
  final Duration? reverseDuration;

  /* AUTOGENERATED FROM [AnimatedCrossFade.secondChild]*/
  /// The child that is visible when [crossFadeState] is
  /// [CrossFadeState.showSecond]. It fades in when transitioning
  /// [crossFadeState] from [CrossFadeState.showFirst] to
  /// [CrossFadeState.showSecond] and vice versa.
  final JsonWidgetData secondChild;

  /* AUTOGENERATED FROM [AnimatedCrossFade.secondCurve]*/
  /// The fade curve of the second child.
  ///
  /// Defaults to [Curves.linear].
  final Curve secondCurve;

  /* AUTOGENERATED FROM [AnimatedCrossFade.sizeCurve]*/
  /// The curve of the animation between the two children's sizes.
  ///
  /// Defaults to [Curves.linear].
  final Curve sizeCurve;

  static JsonAnimatedCrossFadeBuilderModel fromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    final result = maybeFromDynamic(map, args: args, registry: registry);

    if (result == null) {
      throw Exception(
        '[JsonAnimatedCrossFadeBuilder]: requested to parse from dynamic, but the input is null.',
      );
    }

    return result;
  }

  static JsonAnimatedCrossFadeBuilderModel? maybeFromDynamic(
    dynamic map, {
    Map<String, dynamic> args = const {},
    JsonWidgetRegistry? registry,
  }) {
    JsonAnimatedCrossFadeBuilderModel? result;

    if (map != null) {
      if (map is String) {
        map = yaon.parse(map, normalize: true);
      }

      if (map is JsonAnimatedCrossFadeBuilderModel) {
        result = map;
      } else {
        registry ??= JsonWidgetRegistry.instance;
        map = registry.processArgs(map, <String>{}).value;
        result = JsonAnimatedCrossFadeBuilderModel(
          args,
          alignment: () {
            dynamic parsed = ThemeDecoder.decodeAlignmentGeometry(
              map['alignment'],
              validate: false,
            );
            parsed ??= Alignment.topCenter;

            return parsed;
          }(),
          crossFadeState: () {
            dynamic parsed = ThemeDecoder.decodeCrossFadeState(
              map['crossFadeState'],
              validate: false,
            );

            if (parsed == null) {
              throw Exception(
                'Null value encountered for required parameter: [crossFadeState].',
              );
            }
            return parsed;
          }(),
          duration: () {
            dynamic parsed = JsonClass.parseDurationFromMillis(map['duration']);

            if (parsed == null) {
              throw Exception(
                'Null value encountered for required parameter: [duration].',
              );
            }
            return parsed;
          }(),
          excludeBottomFocus: JsonClass.parseBool(
            map['excludeBottomFocus'],
            whenNull: true,
          ),
          firstChild: () {
            dynamic parsed = JsonWidgetData.fromDynamic(
              map['firstChild'],
              registry: registry,
            );

            if (parsed == null) {
              throw Exception(
                'Null value encountered for required parameter: [firstChild].',
              );
            }
            return parsed;
          }(),
          firstCurve: () {
            dynamic parsed = CurvesValues.lookup(map['firstCurve']);

            parsed ??= Curves.linear;

            return parsed;
          }(),
          layoutBuilder:
              map['layoutBuilder'] ?? AnimatedCrossFade.defaultLayoutBuilder,
          reverseDuration: () {
            dynamic parsed = JsonClass.maybeParseDurationFromMillis(
              map['reverseDuration'],
            );

            return parsed;
          }(),
          secondChild: () {
            dynamic parsed = JsonWidgetData.fromDynamic(
              map['secondChild'],
              registry: registry,
            );

            if (parsed == null) {
              throw Exception(
                'Null value encountered for required parameter: [secondChild].',
              );
            }
            return parsed;
          }(),
          secondCurve: () {
            dynamic parsed = CurvesValues.lookup(map['secondCurve']);

            parsed ??= Curves.linear;

            return parsed;
          }(),
          sizeCurve: () {
            dynamic parsed = CurvesValues.lookup(map['sizeCurve']);

            parsed ??= Curves.linear;

            return parsed;
          }(),
        );
      }
    }

    return result;
  }

  @override
  Map<String, dynamic> toJson() {
    return JsonClass.removeNull({
      'alignment':
          Alignment.topCenter == alignment
              ? null
              : ThemeEncoder.encodeAlignmentGeometry(alignment),
      'crossFadeState': ThemeEncoder.encodeCrossFadeState(crossFadeState),
      'duration': duration.inMilliseconds,
      'excludeBottomFocus':
          true == excludeBottomFocus ? null : excludeBottomFocus,
      'firstChild': firstChild.toJson(),
      'firstCurve':
          Curves.linear == firstCurve ? null : CurvesValues.encode(firstCurve),
      'layoutBuilder':
          AnimatedCrossFade.defaultLayoutBuilder == layoutBuilder
              ? null
              : layoutBuilder,
      'reverseDuration': reverseDuration?.inMilliseconds,
      'secondChild': secondChild.toJson(),
      'secondCurve':
          Curves.linear == secondCurve
              ? null
              : CurvesValues.encode(secondCurve),
      'sizeCurve':
          Curves.linear == sizeCurve ? null : CurvesValues.encode(sizeCurve),

      ...args,
    });
  }
}

class AnimatedCrossFadeSchema {
  static const id =
      'https://peiffer-innovations.github.io/flutter_json_schemas/schemas/json_dynamic_widget/animated_cross_fade.json';

  static final schema = <String, Object>{
    r'$schema': 'http://json-schema.org/draft-07/schema#',
    r'$id': id,
    'title': 'AnimatedCrossFade',
    'type': 'object',
    'additionalProperties': false,
    'properties': {
      'alignment': SchemaHelper.objectSchema(AlignmentGeometrySchema.id),
      'crossFadeState': SchemaHelper.objectSchema(CrossFadeStateSchema.id),
      'duration': SchemaHelper.anySchema,
      'excludeBottomFocus': SchemaHelper.boolSchema,
      'firstChild': SchemaHelper.objectSchema(JsonWidgetDataSchema.id),
      'firstCurve': SchemaHelper.anySchema,
      'layoutBuilder': SchemaHelper.anySchema,
      'reverseDuration': SchemaHelper.anySchema,
      'secondChild': SchemaHelper.objectSchema(JsonWidgetDataSchema.id),
      'secondCurve': SchemaHelper.anySchema,
      'sizeCurve': SchemaHelper.anySchema,
    },
    'required': ['crossFadeState', 'duration', 'firstChild', 'secondChild'],
  };
}
